컬렉션 프레임워크 (Collection Framework)

	1. 데이터를 다루기 위한 표준화된 구조
	
	2. 핵심 구조  (인터페이스)
		Collection	- List	- ArrayList   
							- LinkedList
							- Vector
							
					- Set	- HashSet
		
		Map			- HashMap
	사전이라생각    - SortedMap		- TreeMap
					- Hashtable
					
	3. 주요 인터페이스의 핵심 기능
		1) List
			(1) 순서가 있는 데이터의 집합   (인덱스가 있다.)
			(2) 중복 저장 허용
		2) Set
			(1) 순서가 없는 데이터의 집합 (인덱스가 없다.)
			(2) 중복 저장 불가
		3) Map
			(1) 키(key)와 값(value)의 쌍(pair)으로 이루어진 데이터
			(2) 순서가 없는 데이터의 집합 (인덱스가 없다. 인덱스 대신 키(KEY)를 사용한다.)
			(3) 키(key)는 중복 저장 불가
			(4) 값(value)는 중복 저장 허용
	
	4. 반복자 (Iterator) 를 사용할 수 있다.
		
		List<String> list = new ArrayList<>();
		Iterator itr = list.iterator();		// itr : 컬렉션의 요소를 꺼낼 수 있다.
		
		while (itr.hasNext()) {
			itr.next();
		}


ArrayList

	1. 객체(인스턴스)를 여러 개 저장할 수 있는 "배열"을 구현한 컬렉션이다.
	2. 가장 많이 사용된다.
	3. 기존에는 Vector 를 많이 사용했다.
	4. 장점
		(1) 구조가 단순하다.
		(2) 읽어들이는 속도가 빠르다.
		(3) 저장된 객체들의 변화가 적은 경우에 사용하면 좋다.
	5. 단점
		(1) 일단 만들고 나면 나중에 크기 변경이 힘들다.
		(2) 처음부터 크게 만들면 공간 낭비가 생긴다.
		(3) 비순차적 접근이 느리다.
		(4) 데이터의 중간 위치에 추가/제거가 어렵다.


LinkedList

	1. 자신과 연결된 다음 요소에 대한 "참조 + 데이터" 로 구성된다.
	2. 비연속적인 공간을 사용한다.
	3. 장점
		1) 추가 / 삭제 작업이 빠르다.
		2) 잦은 추가 / 삭제가 발생되는 경우에 사용한다.
	4. 단점
		1) 순차적인 순회가 느리다.
		2) 구현이 어렵고, 오류가 발생할 가능성이 있다.
	

HashSet

	1. Set 인터페이스를 구현한 대표적인 클래스이다.
	2. 중복된 데이터는 저장되지 않는다.
	3. 중복된 데이터 판단 원리
		1) hashCode() 확인
			(1) 값이 같으면 equals() 호출해서 동등 비교
			(2) 값이 다르면 다른 데이터로 판단
		2) equals() 확인
	4. 사용자가 정의한 객체(인스턴스)를 저장하려면 hashCode(), equals() 오버라이드 해야 한다.
	5. 저장 순서가 없다. (add 한 순서대로 유지되지 않는다.)
	6. add 한 순서를 유지하려면 LinkedHashSet 클래스를 사용한다.


HashMap

	1. 해시코드를 사용하는 Map 이다. (많은 양의 자료에 적합)
	2. 키(key) + 값(value)의 조합으로 데이터를 저장한다.
	3. 인덱스 대신 키(key) 값을 사용한다.